// Code generated by parsegen; DO NOT EDIT.
package twig

import (
	"io"
)

// NodeType represents the type of a node
type NodeType int

// Node types
const (
	NodeRoot NodeType = iota
	NodeText
	NodePrint
	NodeIf
	NodeFor
	NodeSet
	NodeBlock
	NodeExtends
	NodeInclude
	NodeMacro
	NodeImport
	NodeExpression
	NodeVariable
	NodeLiteral
	NodeUnary
	NodeBinary
	NodeAttribute
)

// Node represents a node in the abstract syntax tree
type Node interface {
	// Render renders the node to the given writer
	Render(w io.Writer, ctx *RenderContext) error

	// Type returns the type of the node
	Type() NodeType

	// Line returns the line number where the node was defined
	Line() int
}

// MacroNode represents a macro definition
type MacroNode struct {
	name     string
	params   []string
	defaults map[string]Node
	body     []Node
	line     int
}

// Implement Node interface for MacroNode
func (n *MacroNode) Render(w io.Writer, ctx *RenderContext) error {
	// Register the macro in the context
	if ctx.macros == nil {
		ctx.macros = make(map[string]Node)
	}
	ctx.macros[n.name] = n
	return nil
}

func (n *MacroNode) Type() NodeType {
	return NodeMacro
}

func (n *MacroNode) Line() int {
	return n.line
}

// Call executes the macro with the given arguments
func (n *MacroNode) Call(w io.Writer, ctx *RenderContext, args []interface{}) error {
	// Create a new context for the macro
	macroContext := &RenderContext{
		env:     ctx.env,
		context: make(map[string]interface{}),
		blocks:  ctx.blocks,
		macros:  ctx.macros,
		parent:  ctx.parent,
		engine:  ctx.engine,
	}

	// Set parameter values from arguments
	for i, param := range n.params {
		if i < len(args) {
			// Use provided argument
			macroContext.context[param] = args[i]
		} else if defaultValue, ok := n.defaults[param]; ok {
			// Use default value
			value, err := ctx.EvaluateExpression(defaultValue)
			if err != nil {
				return err
			}
			macroContext.context[param] = value
		} else {
			// No argument or default, set to nil
			macroContext.context[param] = nil
		}
	}

	// Render the macro body
	for _, node := range n.body {
		if err := node.Render(w, macroContext); err != nil {
			return err
		}
	}

	return nil
}

// ImportNode represents an import statement
type ImportNode struct {
	source string
	module string
	line   int
}

// Implement Node interface for ImportNode
func (n *ImportNode) Render(w io.Writer, ctx *RenderContext) error {
	// Load the imported template
	template, err := ctx.engine.Load(n.source)
	if err != nil {
		return err
	}

	// Create a context for the imported template
	importContext := &RenderContext{
		env:     ctx.env,
		context: make(map[string]interface{}),
		blocks:  make(map[string][]Node),
		macros:  make(map[string]Node),
		engine:  ctx.engine,
	}

	// Render the template to collect macros (without output)
	var nullWriter NullWriter
	if err := template.nodes.Render(&nullWriter, importContext); err != nil {
		return err
	}

	// Create a module object to hold the imported macros
	module := make(map[string]interface{})

	// Add all macros from the imported template to the module
	for name, macro := range importContext.macros {
		module[name] = macro
	}

	// Set the module in the current context
	ctx.SetVariable(n.module, module)

	return nil
}

func (n *ImportNode) Type() NodeType {
	return NodeImport
}

func (n *ImportNode) Line() int {
	return n.line
}

// FromImportNode represents a from...import statement
type FromImportNode struct {
	source  string
	macros  []string
	aliases map[string]string
	line    int
}

// Implement Node interface for FromImportNode
func (n *FromImportNode) Render(w io.Writer, ctx *RenderContext) error {
	// Load the imported template
	template, err := ctx.engine.Load(n.source)
	if err != nil {
		return err
	}

	// Create a context for the imported template
	importContext := &RenderContext{
		env:     ctx.env,
		context: make(map[string]interface{}),
		blocks:  make(map[string][]Node),
		macros:  make(map[string]Node),
		engine:  ctx.engine,
	}

	// Render the template to collect macros (without output)
	var nullWriter NullWriter
	if err := template.nodes.Render(&nullWriter, importContext); err != nil {
		return err
	}

	// Import the specified macros directly into the current context
	if len(n.macros) > 0 {
		for _, name := range n.macros {
			if macro, ok := importContext.macros[name]; ok {
				ctx.macros[name] = macro
			}
		}
	}

	// Import macros with aliases
	if len(n.aliases) > 0 {
		for name, alias := range n.aliases {
			if macro, ok := importContext.macros[name]; ok {
				ctx.macros[alias] = macro
			}
		}
	}

	return nil
}

func (n *FromImportNode) Type() NodeType {
	return NodeImport
}

func (n *FromImportNode) Line() int {
	return n.line
}

// FilterNode represents a filter application
type FilterNode struct {
	node   Node
	filter string
	args   []Node
	line   int
}

// Implement Node interface for FilterNode
func (n *FilterNode) Render(w io.Writer, ctx *RenderContext) error {
	// Evaluate the input node
	input, err := ctx.EvaluateExpression(n.node)
	if err != nil {
		return err
	}

	// Evaluate filter arguments
	var args []interface{}
	for _, arg := range n.args {
		argValue, err := ctx.EvaluateExpression(arg)
		if err != nil {
			return err
		}
		args = append(args, argValue)
	}

	// Apply the filter
	result, err := ctx.ApplyFilter(n.filter, input, args)
	if err != nil {
		return err
	}

	// Write the result
	_, err = w.Write([]byte(ctx.ToString(result)))
	return err
}

func (n *FilterNode) Type() NodeType {
	return NodeExpression
}

func (n *FilterNode) Line() int {
	return n.line
}

// NullWriter is a writer that discards all data
type NullWriter struct{}

func (w *NullWriter) Write(p []byte) (n int, err error) {
	return len(p), nil
}

// Constructor functions for new node types

// NewMacroNode creates a new macro node
func NewMacroNode(name string, params []string, defaults map[string]Node, body []Node, line int) *MacroNode {
	return &MacroNode{
		name:     name,
		params:   params,
		defaults: defaults,
		body:     body,
		line:     line,
	}
}

// NewImportNode creates a new import node
func NewImportNode(source Node, module string, line int) *ImportNode {
	sourceStr, _ := source.(*LiteralNode)
	return &ImportNode{
		source: sourceStr.value.(string),
		module: module,
		line:   line,
	}
}

// NewFromImportNode creates a new from...import node
func NewFromImportNode(source Node, macros []string, aliases map[string]string, line int) *FromImportNode {
	sourceStr, _ := source.(*LiteralNode)
	return &FromImportNode{
		source:  sourceStr.value.(string),
		macros:  macros,
		aliases: aliases,
		line:    line,
	}
}

// NewFilterNode creates a new filter node
func NewFilterNode(node Node, filter string, args []Node, line int) *FilterNode {
	return &FilterNode{
		node:   node,
		filter: filter,
		args:   args,
		line:   line,
	}
}
