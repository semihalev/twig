package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// GrammarRule represents a production rule in the grammar
type GrammarRule struct {
	Name        string
	Alternatives [][]string
	ReturnType   string
	NodeType     string
	Description  string
}

// Define the parser template
const parserTmpl = `// Code generated by parsegen; DO NOT EDIT.
package twig

import (
	"fmt"
)

// Parser is responsible for parsing tokens into an abstract syntax tree
type Parser struct {
	lexer      *Lexer
	tokens     []Token
	currentPos int
	errors     []string
}

// NewParser creates a new parser for the given lexer
func NewParser(source string) *Parser {
	lexer := NewLexer(source)
	return &Parser{
		lexer:      lexer,
		tokens:     nil,
		currentPos: 0,
		errors:     []string{},
	}
}

// Parse parses a template source into a node tree
func (p *Parser) Parse() (Node, error) {
	// Tokenize the source
	var err error
	p.tokens, err = p.lexer.Tokenize()
	if err != nil {
		return nil, fmt.Errorf("lexer error: %w", err)
	}

	// Parse the program
	node, err := p.parseTemplate()
	if err != nil {
		return nil, err
	}

	// Check if we've consumed all tokens except EOF
	if p.currentPos < len(p.tokens)-1 {
		return nil, fmt.Errorf("unexpected token %s at line %d, column %d", 
			GetTokenName(p.tokens[p.currentPos].Type), 
			p.tokens[p.currentPos].Line, 
			p.tokens[p.currentPos].Col)
	}

	return node, nil
}

// Helper methods for the parser

// current returns the current token
func (p *Parser) current() Token {
	if p.currentPos >= len(p.tokens) {
		return Token{Type: T_EOF}
	}
	return p.tokens[p.currentPos]
}

// peek returns the token at the given offset from the current position
func (p *Parser) peek(offset int) Token {
	pos := p.currentPos + offset
	if pos >= len(p.tokens) {
		return Token{Type: T_EOF}
	}
	return p.tokens[pos]
}

// advance moves to the next token
func (p *Parser) advance() Token {
	if p.currentPos >= len(p.tokens) {
		return Token{Type: T_EOF}
	}
	token := p.tokens[p.currentPos]
	p.currentPos++
	return token
}

// match checks if the current token is of the expected type
func (p *Parser) match(types ...TokenType) bool {
	for _, typ := range types {
		if p.current().Type == typ {
			p.advance()
			return true
		}
	}
	return false
}

// expect advances if the current token is of the expected type, otherwise adds an error
func (p *Parser) expect(typ TokenType, msg string) bool {
	if p.current().Type == typ {
		p.advance()
		return true
	}
	p.addError(msg)
	return false
}

// addError adds an error message
func (p *Parser) addError(msg string) {
	token := p.current()
	p.errors = append(p.errors, fmt.Sprintf("Error at line %d, column %d: %s", token.Line, token.Col, msg))
}

// parseTemplate parses the entire template
func (p *Parser) parseTemplate() (Node, error) {
	nodes := make([]Node, 0)
	
	for p.current().Type != T_EOF {
		switch p.current().Type {
		case T_TEXT:
			// Parse text node
			node := NewTextNode(p.current().Value, p.current().Line)
			nodes = append(nodes, node)
			p.advance()
			
		case T_OPEN_VAR:
			// Parse variable output
			p.advance() // consume {{
			expr, err := p.parseExpression()
			if err != nil {
				return nil, err
			}
			
			if !p.expect(T_CLOSE_VAR, "Expected '}}' after expression") {
				return nil, fmt.Errorf("expected }} after expression at line %d", p.current().Line)
			}
			
			nodes = append(nodes, NewPrintNode(expr, p.current().Line))
			
		case T_OPEN_BLOCK:
			// Parse block
			p.advance() // consume {%
			
			if p.current().Type != T_IDENT && 
			   (p.current().Type < T_IF || p.current().Type > T_MISSING) {
				return nil, fmt.Errorf("expected block name at line %d", p.current().Line)
			}
			
			blockNode, err := p.parseBlockTag()
			if err != nil {
				return nil, err
			}
			
			if blockNode != nil {
				nodes = append(nodes, blockNode)
			}
			
		case T_OPEN_COMMENT:
			// Skip comments
			p.advance() // consume {#
			
			// Find end of comment
			for p.current().Type != T_CLOSE_COMMENT && p.current().Type != T_EOF {
				p.advance()
			}
			
			if p.current().Type == T_EOF {
				return nil, fmt.Errorf("unterminated comment")
			}
			
			p.advance() // consume #}
			
		default:
			return nil, fmt.Errorf("unexpected token %s at line %d", 
				GetTokenName(p.current().Type), p.current().Line)
		}
	}
	
	return NewRootNode(nodes, 1), nil
}

// parseBlockTag parses a block tag
func (p *Parser) parseBlockTag() (Node, error) {
	// Save the starting token
	startToken := p.current()
	
	// Dispatch based on the block type
	switch p.current().Type {
	case T_IF:
		return p.parseIf()
	case T_FOR:
		return p.parseFor()
	case T_SET:
		return p.parseSet()
	case T_BLOCK:
		return p.parseBlock()
	case T_EXTENDS:
		return p.parseExtends()
	case T_INCLUDE:
		return p.parseInclude()
	case T_MACRO:
		return p.parseMacro()
	case T_IMPORT, T_FROM:
		return p.parseImport()
	case T_ENDIF, T_ENDFOR, T_ENDBLOCK, T_ENDMACRO, T_ELSE, T_ELSEIF:
		// These should be handled by their corresponding open tags
		return nil, fmt.Errorf("unexpected '%s' tag at line %d", p.current().Value, p.current().Line)
	default:
		if p.current().Type == T_IDENT {
			// Handle custom tags
			return nil, fmt.Errorf("unknown tag '%s' at line %d", p.current().Value, p.current().Line)
		}
		return nil, fmt.Errorf("unexpected token %s at line %d", 
			GetTokenName(p.current().Type), p.current().Line)
	}
}

// parseIf parses an if statement
func (p *Parser) parseIf() (Node, error) {
	ifLine := p.current().Line
	p.advance() // consume 'if'
	
	// Parse the condition
	condition, err := p.parseExpression()
	if err != nil {
		return nil, err
	}
	
	if !p.expect(T_CLOSE_BLOCK, "Expected '%}' after if condition") {
		return nil, fmt.Errorf("expected %%} after if condition at line %d", p.current().Line)
	}
	
	// Parse the if body
	ifBody := make([]Node, 0)
	for {
		// Check for the end of the if
		if p.current().Type == T_OPEN_BLOCK && 
		  (p.peek(1).Type == T_ENDIF || p.peek(1).Type == T_ELSE || p.peek(1).Type == T_ELSEIF) {
			break
		}
		
		// Parse body nodes
		node, err := p.parseTemplate()
		if err != nil {
			return nil, err
		}
		
		// Add the node to the body
		// Note: This will add a RootNode, but that's fine, we'll extract its children later
		ifBody = append(ifBody, node)
	}
	
	// Extract children from RootNode
	for i, node := range ifBody {
		if rootNode, ok := node.(*RootNode); ok {
			ifBody = append(ifBody[:i], rootNode.children...)
		}
	}
	
	var elseBranch []Node
	
	// Check for else or endif
	if p.current().Type == T_OPEN_BLOCK {
		p.advance() // consume {%
		
		if p.current().Type == T_ELSE {
			p.advance() // consume 'else'
			
			if !p.expect(T_CLOSE_BLOCK, "Expected '%}' after else") {
				return nil, fmt.Errorf("expected %%} after else at line %d", p.current().Line)
			}
			
			// Parse the else body
			elseBranch = make([]Node, 0)
			for {
				// Check for the end of the else
				if p.current().Type == T_OPEN_BLOCK && p.peek(1).Type == T_ENDIF {
					break
				}
				
				// Parse body nodes
				node, err := p.parseTemplate()
				if err != nil {
					return nil, err
				}
				
				// Add the node to the body
				elseBranch = append(elseBranch, node)
			}
			
			// Extract children from RootNode
			for i, node := range elseBranch {
				if rootNode, ok := node.(*RootNode); ok {
					elseBranch = append(elseBranch[:i], rootNode.children...)
				}
			}
			
			// Expect endif
			p.advance() // consume {%
			
			if !p.expect(T_ENDIF, "Expected 'endif' after else block") {
				return nil, fmt.Errorf("expected endif after else block at line %d", p.current().Line)
			}
		} else if p.current().Type == T_ENDIF {
			p.advance() // consume 'endif'
		} else {
			return nil, fmt.Errorf("expected else or endif, got %s at line %d", 
				GetTokenName(p.current().Type), p.current().Line)
		}
		
		// Expect closing %}
		if !p.expect(T_CLOSE_BLOCK, "Expected '%}' after endif") {
			return nil, fmt.Errorf("expected %%} after endif at line %d", p.current().Line)
		}
	}
	
	// Create the if node
	return NewIfNode(condition, ifBody, elseBranch, ifLine), nil
}

// parseFor parses a for loop
func (p *Parser) parseFor() (Node, error) {
	forLine := p.current().Line
	p.advance() // consume 'for'
	
	// Parse the loop variable(s)
	if p.current().Type != T_IDENT {
		return nil, fmt.Errorf("expected variable name after for at line %d", forLine)
	}
	
	valueVar := p.current().Value
	p.advance()
	
	var keyVar string
	
	// Check for key, value syntax
	if p.current().Type == T_COMMA {
		p.advance() // consume comma
		
		// Now valueVar is actually the key
		keyVar = valueVar
		
		if p.current().Type != T_IDENT {
			return nil, fmt.Errorf("expected variable name after comma at line %d", forLine)
		}
		
		valueVar = p.current().Value
		p.advance()
	}
	
	// Expect 'in' keyword
	if p.current().Type != T_IN {
		return nil, fmt.Errorf("expected 'in' keyword after variable at line %d", forLine)
	}
	p.advance() // consume 'in'
	
	// Parse the sequence expression
	sequence, err := p.parseExpression()
	if err != nil {
		return nil, err
	}
	
	// Expect %}
	if !p.expect(T_CLOSE_BLOCK, "Expected '%}' after for statement") {
		return nil, fmt.Errorf("expected %%} after for statement at line %d", p.current().Line)
	}
	
	// Parse the loop body
	loopBody := make([]Node, 0)
	for {
		// Check for the end of the loop
		if p.current().Type == T_OPEN_BLOCK && 
		  (p.peek(1).Type == T_ENDFOR || p.peek(1).Type == T_ELSE) {
			break
		}
		
		// Parse body nodes
		node, err := p.parseTemplate()
		if err != nil {
			return nil, err
		}
		
		// Add the node to the body
		loopBody = append(loopBody, node)
	}
	
	// Extract children from RootNode
	for i, node := range loopBody {
		if rootNode, ok := node.(*RootNode); ok {
			loopBody = append(loopBody[:i], rootNode.children...)
		}
	}
	
	var elseBranch []Node
	
	// Check for else or endfor
	if p.current().Type == T_OPEN_BLOCK {
		p.advance() // consume {%
		
		if p.current().Type == T_ELSE {
			p.advance() // consume 'else'
			
			if !p.expect(T_CLOSE_BLOCK, "Expected '%}' after else") {
				return nil, fmt.Errorf("expected %%} after else at line %d", p.current().Line)
			}
			
			// Parse the else body
			elseBranch = make([]Node, 0)
			for {
				// Check for the end of the else
				if p.current().Type == T_OPEN_BLOCK && p.peek(1).Type == T_ENDFOR {
					break
				}
				
				// Parse body nodes
				node, err := p.parseTemplate()
				if err != nil {
					return nil, err
				}
				
				// Add the node to the body
				elseBranch = append(elseBranch, node)
			}
			
			// Extract children from RootNode
			for i, node := range elseBranch {
				if rootNode, ok := node.(*RootNode); ok {
					elseBranch = append(elseBranch[:i], rootNode.children...)
				}
			}
			
			// Expect endfor
			p.advance() // consume {%
			
			if !p.expect(T_ENDFOR, "Expected 'endfor' after else block") {
				return nil, fmt.Errorf("expected endfor after else block at line %d", p.current().Line)
			}
		} else if p.current().Type == T_ENDFOR {
			p.advance() // consume 'endfor'
		} else {
			return nil, fmt.Errorf("expected else or endfor, got %s at line %d", 
				GetTokenName(p.current().Type), p.current().Line)
		}
		
		// Expect closing %}
		if !p.expect(T_CLOSE_BLOCK, "Expected '%}' after endfor") {
			return nil, fmt.Errorf("expected %%} after endfor at line %d", p.current().Line)
		}
	}
	
	// Create the for node
	return NewForNode(keyVar, valueVar, sequence, loopBody, elseBranch, forLine), nil
}

// parseSet parses a set statement
func (p *Parser) parseSet() (Node, error) {
	setLine := p.current().Line
	p.advance() // consume 'set'
	
	// Parse the variable name
	if p.current().Type != T_IDENT {
		return nil, fmt.Errorf("expected variable name after set at line %d", setLine)
	}
	
	varName := p.current().Value
	p.advance()
	
	// Expect '='
	if p.current().Type != T_OP_ASSIGN {
		return nil, fmt.Errorf("expected '=' after variable name at line %d", setLine)
	}
	p.advance() // consume '='
	
	// Parse the value expression
	valueExpr, err := p.parseExpression()
	if err != nil {
		return nil, err
	}
	
	// Expect %}
	if !p.expect(T_CLOSE_BLOCK, "Expected '%}' after set statement") {
		return nil, fmt.Errorf("expected %%} after set statement at line %d", p.current().Line)
	}
	
	// Create the set node
	return NewSetNode(varName, valueExpr, setLine), nil
}

// parseBlock parses a block definition
func (p *Parser) parseBlock() (Node, error) {
	blockLine := p.current().Line
	p.advance() // consume 'block'
	
	// Parse the block name
	if p.current().Type != T_IDENT {
		return nil, fmt.Errorf("expected block name at line %d", blockLine)
	}
	
	blockName := p.current().Value
	p.advance()
	
	// Expect %}
	if !p.expect(T_CLOSE_BLOCK, "Expected '%}' after block name") {
		return nil, fmt.Errorf("expected %%} after block name at line %d", p.current().Line)
	}
	
	// Parse the block body
	blockBody := make([]Node, 0)
	for {
		// Check for the end of the block
		if p.current().Type == T_OPEN_BLOCK && p.peek(1).Type == T_ENDBLOCK {
			break
		}
		
		// Parse body nodes
		node, err := p.parseTemplate()
		if err != nil {
			return nil, err
		}
		
		// Add the node to the body
		blockBody = append(blockBody, node)
	}
	
	// Extract children from RootNode
	for i, node := range blockBody {
		if rootNode, ok := node.(*RootNode); ok {
			blockBody = append(blockBody[:i], rootNode.children...)
		}
	}
	
	// Expect endblock
	p.advance() // consume {%
	
	if !p.expect(T_ENDBLOCK, "Expected 'endblock' after block content") {
		return nil, fmt.Errorf("expected endblock at line %d", p.current().Line)
	}
	
	// Check for optional block name in endblock
	if p.current().Type == T_IDENT {
		endBlockName := p.current().Value
		if endBlockName != blockName {
			return nil, fmt.Errorf("mismatched block name, expected %s but got %s at line %d", 
				blockName, endBlockName, p.current().Line)
		}
		p.advance()
	}
	
	// Expect %}
	if !p.expect(T_CLOSE_BLOCK, "Expected '%}' after endblock") {
		return nil, fmt.Errorf("expected %%} after endblock at line %d", p.current().Line)
	}
	
	// Create the block node
	return NewBlockNode(blockName, blockBody, blockLine), nil
}

// parseExtends parses an extends statement
func (p *Parser) parseExtends() (Node, error) {
	extendsLine := p.current().Line
	p.advance() // consume 'extends'
	
	// Parse the parent template expression
	parentExpr, err := p.parseExpression()
	if err != nil {
		return nil, err
	}
	
	// Expect %}
	if !p.expect(T_CLOSE_BLOCK, "Expected '%}' after extends") {
		return nil, fmt.Errorf("expected %%} after extends at line %d", p.current().Line)
	}
	
	// Create the extends node
	return NewExtendsNode(parentExpr, extendsLine), nil
}

// parseInclude parses an include statement
func (p *Parser) parseInclude() (Node, error) {
	includeLine := p.current().Line
	p.advance() // consume 'include'
	
	// Parse the template expression
	templateExpr, err := p.parseExpression()
	if err != nil {
		return nil, err
	}
	
	// Process optional arguments
	var variables map[string]Node
	var ignoreMissing bool
	var onlyContext bool
	
	for p.current().Type == T_WITH || p.current().Type == T_IGNORE || p.current().Type == T_ONLY {
		switch p.current().Type {
		case T_WITH:
			p.advance() // consume 'with'
			
			// Initialize variables map
			if variables == nil {
				variables = make(map[string]Node)
			}
			
			// Parse variable assignments
			for p.current().Type == T_IDENT {
				varName := p.current().Value
				p.advance()
				
				// Expect '='
				if !p.expect(T_OP_ASSIGN, "Expected '=' after variable name") {
					return nil, fmt.Errorf("expected '=' after variable name at line %d", p.current().Line)
				}
				
				// Parse the value
				varExpr, err := p.parseExpression()
				if err != nil {
					return nil, err
				}
				
				// Add to variables
				variables[varName] = varExpr
				
				// Check for comma
				if p.current().Type == T_COMMA {
					p.advance()
				} else {
					break
				}
			}
			
		case T_IGNORE:
			p.advance() // consume 'ignore'
			
			// Expect 'missing'
			if !p.expect(T_MISSING, "Expected 'missing' after 'ignore'") {
				return nil, fmt.Errorf("expected 'missing' after 'ignore' at line %d", p.current().Line)
			}
			
			ignoreMissing = true
			
		case T_ONLY:
			p.advance() // consume 'only'
			onlyContext = true
		}
	}
	
	// Expect %}
	if !p.expect(T_CLOSE_BLOCK, "Expected '%}' after include") {
		return nil, fmt.Errorf("expected %%} after include at line %d", p.current().Line)
	}
	
	// Create the include node
	return NewIncludeNode(templateExpr, variables, ignoreMissing, onlyContext, includeLine), nil
}

// parseMacro parses a macro definition
func (p *Parser) parseMacro() (Node, error) {
	macroLine := p.current().Line
	p.advance() // consume 'macro'
	
	// Parse the macro name
	if p.current().Type != T_IDENT {
		return nil, fmt.Errorf("expected macro name at line %d", macroLine)
	}
	
	macroName := p.current().Value
	p.advance()
	
	// Expect opening parenthesis
	if !p.expect(T_LPAREN, "Expected '(' after macro name") {
		return nil, fmt.Errorf("expected '(' after macro name at line %d", p.current().Line)
	}
	
	// Parse parameters
	var params []string
	var defaults map[string]Node
	
	if p.current().Type != T_RPAREN {
		// We have parameters
		for {
			// Parse parameter name
			if p.current().Type != T_IDENT {
				return nil, fmt.Errorf("expected parameter name at line %d", p.current().Line)
			}
			
			paramName := p.current().Value
			p.advance()
			
			// Add to parameters list
			params = append(params, paramName)
			
			// Check for default value
			if p.current().Type == T_OP_ASSIGN {
				p.advance() // consume '='
				
				// Initialize defaults map if needed
				if defaults == nil {
					defaults = make(map[string]Node)
				}
				
				// Parse default value
				defaultExpr, err := p.parseExpression()
				if err != nil {
					return nil, err
				}
				
				// Add to defaults
				defaults[paramName] = defaultExpr
			}
			
			// Check for comma or end of parameters
			if p.current().Type == T_COMMA {
				p.advance()
			} else {
				break
			}
		}
	}
	
	// Expect closing parenthesis
	if !p.expect(T_RPAREN, "Expected ')' after parameters") {
		return nil, fmt.Errorf("expected ')' after parameters at line %d", p.current().Line)
	}
	
	// Expect %}
	if !p.expect(T_CLOSE_BLOCK, "Expected '%}' after macro declaration") {
		return nil, fmt.Errorf("expected %%} after macro declaration at line %d", p.current().Line)
	}
	
	// Parse the macro body
	macroBody := make([]Node, 0)
	for {
		// Check for the end of the macro
		if p.current().Type == T_OPEN_BLOCK && p.peek(1).Type == T_ENDMACRO {
			break
		}
		
		// Parse body nodes
		node, err := p.parseTemplate()
		if err != nil {
			return nil, err
		}
		
		// Add the node to the body
		macroBody = append(macroBody, node)
	}
	
	// Extract children from RootNode
	for i, node := range macroBody {
		if rootNode, ok := node.(*RootNode); ok {
			macroBody = append(macroBody[:i], rootNode.children...)
		}
	}
	
	// Expect endmacro
	p.advance() // consume {%
	
	if !p.expect(T_ENDMACRO, "Expected 'endmacro'") {
		return nil, fmt.Errorf("expected endmacro at line %d", p.current().Line)
	}
	
	// Expect %}
	if !p.expect(T_CLOSE_BLOCK, "Expected '%}' after endmacro") {
		return nil, fmt.Errorf("expected %%} after endmacro at line %d", p.current().Line)
	}
	
	// Create the macro node
	return NewMacroNode(macroName, params, defaults, macroBody, macroLine), nil
}

// parseImport parses import and from tags
func (p *Parser) parseImport() (Node, error) {
	importLine := p.current().Line
	isFrom := p.current().Type == T_FROM
	
	p.advance() // consume 'import' or 'from'
	
	var sourceExpr Node
	var err error
	
	// Parse template source
	sourceExpr, err = p.parseExpression()
	if err != nil {
		return nil, err
	}
	
	if isFrom {
		// Parse 'import'
		if !p.expect(T_IMPORT, "Expected 'import' after template in from statement") {
			return nil, fmt.Errorf("expected 'import' after template at line %d", p.current().Line)
		}
		
		// Parse imported identifiers
		var macros []string
		var aliases map[string]string
		
		for p.current().Type == T_IDENT || p.current().Type == T_MACRO {
			// Allow 'macro' as an identifier for imported macros
			var name string
			if p.current().Type == T_MACRO {
				name = "macro"
			} else {
				name = p.current().Value
			}
			p.advance()
			
			// Check for alias
			if p.current().Type == T_AS {
				p.advance() // consume 'as'
				
				if p.current().Type != T_IDENT {
					return nil, fmt.Errorf("expected identifier after 'as' at line %d", p.current().Line)
				}
				
				// Initialize aliases map if needed
				if aliases == nil {
					aliases = make(map[string]string)
				}
				
				aliases[name] = p.current().Value
				p.advance()
			} else {
				// No alias, just add to macros list
				macros = append(macros, name)
			}
			
			// Check for comma
			if p.current().Type == T_COMMA {
				p.advance()
			} else {
				break
			}
		}
		
		// Expect %}
		if !p.expect(T_CLOSE_BLOCK, "Expected '%}' after from import") {
			return nil, fmt.Errorf("expected %%} after from import at line %d", p.current().Line)
		}
		
		// Create FromImportNode
		return NewFromImportNode(sourceExpr, macros, aliases, importLine), nil
	} else {
		// Import tag, expect 'as'
		if !p.expect(T_AS, "Expected 'as' after template in import statement") {
			return nil, fmt.Errorf("expected 'as' after template at line %d", p.current().Line)
		}
		
		// Parse the imported module name
		if p.current().Type != T_IDENT {
			return nil, fmt.Errorf("expected module name after 'as' at line %d", p.current().Line)
		}
		
		moduleName := p.current().Value
		p.advance()
		
		// Expect %}
		if !p.expect(T_CLOSE_BLOCK, "Expected '%}' after import") {
			return nil, fmt.Errorf("expected %%} after import at line %d", p.current().Line)
		}
		
		// Create ImportNode
		return NewImportNode(sourceExpr, moduleName, importLine), nil
	}
}

// parseExpression parses an expression
func (p *Parser) parseExpression() (Node, error) {
	return p.parseLogicalOr()
}

// parseLogicalOr parses logical OR expressions
func (p *Parser) parseLogicalOr() (Node, error) {
	left, err := p.parseLogicalAnd()
	if err != nil {
		return nil, err
	}
	
	for p.current().Type == T_OP_OR {
		operator := p.current().Value
		line := p.current().Line
		p.advance()
		
		right, err := p.parseLogicalAnd()
		if err != nil {
			return nil, err
		}
		
		left = NewBinaryNode(operator, left, right, line)
	}
	
	return left, nil
}

// parseLogicalAnd parses logical AND expressions
func (p *Parser) parseLogicalAnd() (Node, error) {
	left, err := p.parseEquality()
	if err != nil {
		return nil, err
	}
	
	for p.current().Type == T_OP_AND {
		operator := p.current().Value
		line := p.current().Line
		p.advance()
		
		right, err := p.parseEquality()
		if err != nil {
			return nil, err
		}
		
		left = NewBinaryNode(operator, left, right, line)
	}
	
	return left, nil
}

// parseEquality parses equality expressions
func (p *Parser) parseEquality() (Node, error) {
	left, err := p.parseComparison()
	if err != nil {
		return nil, err
	}
	
	for p.current().Type == T_OP_EQ || p.current().Type == T_OP_NEQ {
		operator := p.current().Value
		line := p.current().Line
		p.advance()
		
		right, err := p.parseComparison()
		if err != nil {
			return nil, err
		}
		
		left = NewBinaryNode(operator, left, right, line)
	}
	
	return left, nil
}

// parseComparison parses comparison expressions
func (p *Parser) parseComparison() (Node, error) {
	left, err := p.parseAdditive()
	if err != nil {
		return nil, err
	}
	
	for p.current().Type == T_OP_LT || p.current().Type == T_OP_GT || 
		p.current().Type == T_OP_LTE || p.current().Type == T_OP_GTE {
		
		operator := p.current().Value
		line := p.current().Line
		p.advance()
		
		right, err := p.parseAdditive()
		if err != nil {
			return nil, err
		}
		
		left = NewBinaryNode(operator, left, right, line)
	}
	
	return left, nil
}

// parseAdditive parses additive expressions
func (p *Parser) parseAdditive() (Node, error) {
	left, err := p.parseMultiplicative()
	if err != nil {
		return nil, err
	}
	
	for p.current().Type == T_OP_PLUS || p.current().Type == T_OP_MINUS || p.current().Type == T_OP_CONCAT {
		operator := p.current().Value
		line := p.current().Line
		p.advance()
		
		right, err := p.parseMultiplicative()
		if err != nil {
			return nil, err
		}
		
		left = NewBinaryNode(operator, left, right, line)
	}
	
	return left, nil
}

// parseMultiplicative parses multiplicative expressions
func (p *Parser) parseMultiplicative() (Node, error) {
	left, err := p.parseUnary()
	if err != nil {
		return nil, err
	}
	
	for p.current().Type == T_OP_MUL || p.current().Type == T_OP_DIV || p.current().Type == T_OP_MOD {
		operator := p.current().Value
		line := p.current().Line
		p.advance()
		
		right, err := p.parseUnary()
		if err != nil {
			return nil, err
		}
		
		left = NewBinaryNode(operator, left, right, line)
	}
	
	return left, nil
}

// parseUnary parses unary expressions
func (p *Parser) parseUnary() (Node, error) {
	if p.current().Type == T_OP_NOT || p.current().Type == T_OP_MINUS {
		operator := p.current().Value
		line := p.current().Line
		p.advance()
		
		right, err := p.parseUnary()
		if err != nil {
			return nil, err
		}
		
		return NewUnaryNode(operator, right, line), nil
	}
	
	return p.parsePrimary()
}

// parsePrimary parses primary expressions
func (p *Parser) parsePrimary() (Node, error) {
	switch p.current().Type {
	case T_NUMBER:
		// Parse number
		value := p.current().Value
		line := p.current().Line
		p.advance()
		
		// Convert to int or float
		var numValue interface{}
		if strings.Contains(value, ".") {
			// Float
			numValue = parseFloat(value)
		} else {
			// Integer
			numValue = parseInt(value)
		}
		
		return NewLiteralNode(numValue, line), nil
		
	case T_STRING:
		// Parse string literal
		value := p.current().Value
		line := p.current().Line
		p.advance()
		
		// Remove quotes
		if len(value) >= 2 {
			value = value[1:len(value)-1]
		}
		
		return NewLiteralNode(value, line), nil
		
	case T_IDENT:
		// Parse variable or function call
		name := p.current().Value
		line := p.current().Line
		p.advance()
		
		// Check for function call
		if p.current().Type == T_LPAREN {
			return p.parseCall(name, line)
		}
		
		// Variable reference
		var result Node = NewVariableNode(name, line)
		
		// Check for attribute access
		for p.current().Type == T_DOT || p.current().Type == T_LBRACKET {
			if p.current().Type == T_DOT {
				// Object property access
				p.advance() // consume dot
				
				if p.current().Type != T_IDENT {
					return nil, fmt.Errorf("expected identifier after '.' at line %d", line)
				}
				
				attrName := p.current().Value
				attrNode := NewLiteralNode(attrName, p.current().Line)
				result = NewGetAttrNode(result, attrNode, line)
				p.advance()
			} else {
				// Array index access
				p.advance() // consume [
				
				// Parse index expression
				indexExpr, err := p.parseExpression()
				if err != nil {
					return nil, err
				}
				
				if !p.expect(T_RBRACKET, "Expected ']' after index expression") {
					return nil, fmt.Errorf("expected ']' after index at line %d", line)
				}
				
				result = NewGetItemNode(result, indexExpr, line)
			}
		}
		
		// Check for filters
		for p.current().Type == T_PIPE {
			p.advance() // consume |
			
			if p.current().Type != T_IDENT {
				return nil, fmt.Errorf("expected filter name after '|' at line %d", line)
			}
			
			filterName := p.current().Value
			p.advance()
			
			// Parse filter arguments
			var args []Node
			
			if p.current().Type == T_LPAREN {
				p.advance() // consume (
				
				// Parse argument list
				if p.current().Type != T_RPAREN {
					for {
						// Parse argument expression
						argExpr, err := p.parseExpression()
						if err != nil {
							return nil, err
						}
						
						args = append(args, argExpr)
						
						// Check for comma or end of arguments
						if p.current().Type == T_COMMA {
							p.advance()
						} else {
							break
						}
					}
				}
				
				if !p.expect(T_RPAREN, "Expected ')' after filter arguments") {
					return nil, fmt.Errorf("expected ')' after filter arguments at line %d", line)
				}
			}
			
			result = NewFilterNode(result, filterName, args, line)
		}
		
		return result, nil
		
	case T_LPAREN:
		// Grouping
		p.advance() // consume (
		
		expr, err := p.parseExpression()
		if err != nil {
			return nil, err
		}
		
		if !p.expect(T_RPAREN, "Expected ')' after expression") {
			return nil, fmt.Errorf("expected ')' after expression at line %d", p.current().Line)
		}
		
		return expr, nil
		
	case T_LBRACKET:
		// Array literal
		return p.parseArrayLiteral()
		
	case T_LBRACE:
		// Hash/map literal
		return p.parseHashLiteral()
		
	default:
		return nil, fmt.Errorf("unexpected token %s in expression at line %d", 
			GetTokenName(p.current().Type), p.current().Line)
	}
}

// parseCall parses a function call
func (p *Parser) parseCall(name string, line int) (Node, error) {
	p.advance() // consume (
	
	// Parse arguments
	var args []Node
	
	if p.current().Type != T_RPAREN {
		for {
			// Parse argument expression
			argExpr, err := p.parseExpression()
			if err != nil {
				return nil, err
			}
			
			args = append(args, argExpr)
			
			// Check for comma or end of arguments
			if p.current().Type == T_COMMA {
				p.advance()
			} else {
				break
			}
		}
	}
	
	if !p.expect(T_RPAREN, "Expected ')' after function arguments") {
		return nil, fmt.Errorf("expected ')' after function arguments at line %d", line)
	}
	
	return NewFunctionNode(name, args, line), nil
}

// parseArrayLiteral parses an array literal expression
func (p *Parser) parseArrayLiteral() (Node, error) {
	line := p.current().Line
	p.advance() // consume [
	
	var items []Node
	
	if p.current().Type != T_RBRACKET {
		for {
			// Parse item expression
			itemExpr, err := p.parseExpression()
			if err != nil {
				return nil, err
			}
			
			items = append(items, itemExpr)
			
			// Check for comma or end of items
			if p.current().Type == T_COMMA {
				p.advance()
			} else {
				break
			}
		}
	}
	
	if !p.expect(T_RBRACKET, "Expected ']' after array items") {
		return nil, fmt.Errorf("expected ']' after array items at line %d", line)
	}
	
	return NewArrayNode(items, line), nil
}

// parseHashLiteral parses a hash/map literal expression
func (p *Parser) parseHashLiteral() (Node, error) {
	line := p.current().Line
	p.advance() // consume {
	
	items := make(map[string]Node)
	
	if p.current().Type != T_RBRACE {
		for {
			// Parse key
			var key string
			
			if p.current().Type == T_STRING {
				// String literal key
				value := p.current().Value
				if len(value) >= 2 {
					key = value[1:len(value)-1] // Remove quotes
				}
				p.advance()
			} else if p.current().Type == T_IDENT {
				// Identifier as key
				key = p.current().Value
				p.advance()
			} else {
				return nil, fmt.Errorf("expected string or identifier as hash key at line %d", line)
			}
			
			// Expect colon
			if !p.expect(T_COLON, "Expected ':' after hash key") {
				return nil, fmt.Errorf("expected ':' after hash key at line %d", line)
			}
			
			// Parse value expression
			valueExpr, err := p.parseExpression()
			if err != nil {
				return nil, err
			}
			
			items[key] = valueExpr
			
			// Check for comma or end of items
			if p.current().Type == T_COMMA {
				p.advance()
			} else {
				break
			}
		}
	}
	
	if !p.expect(T_RBRACE, "Expected '}' after hash items") {
		return nil, fmt.Errorf("expected '}' after hash items at line %d", line)
	}
	
	return NewHashNode(items, line), nil
}

// Helper functions for number conversion
func parseInt(s string) int {
	v, _ := strconv.ParseInt(s, 10, 0)
	return int(v)
}

func parseFloat(s string) float64 {
	v, _ := strconv.ParseFloat(s, 64)
	return v
}
`

// Define the AST node template
const nodesTmpl = `// Code generated by parsegen; DO NOT EDIT.
package twig

import (
	"io"
)

// MacroNode represents a macro definition
type MacroNode struct {
	name     string
	params   []string
	defaults map[string]Node
	body     []Node
	line     int
}

// Implement Node interface for MacroNode
func (n *MacroNode) Render(w io.Writer, ctx *RenderContext) error {
	// Register the macro in the context
	if ctx.macros == nil {
		ctx.macros = make(map[string]Node)
	}
	ctx.macros[n.name] = n
	return nil
}

func (n *MacroNode) Type() NodeType {
	return NodeMacro
}

func (n *MacroNode) Line() int {
	return n.line
}

// Call executes the macro with the given arguments
func (n *MacroNode) Call(w io.Writer, ctx *RenderContext, args []interface{}) error {
	// Create a new context for the macro
	macroContext := &RenderContext{
		env:     ctx.env,
		context: make(map[string]interface{}),
		blocks:  ctx.blocks,
		macros:  ctx.macros,
		parent:  ctx.parent,
		engine:  ctx.engine,
	}
	
	// Set parameter values from arguments
	for i, param := range n.params {
		if i < len(args) {
			// Use provided argument
			macroContext.context[param] = args[i]
		} else if defaultValue, ok := n.defaults[param]; ok {
			// Use default value
			value, err := ctx.EvaluateExpression(defaultValue)
			if err != nil {
				return err
			}
			macroContext.context[param] = value
		} else {
			// No argument or default, set to nil
			macroContext.context[param] = nil
		}
	}
	
	// Render the macro body
	for _, node := range n.body {
		if err := node.Render(w, macroContext); err != nil {
			return err
		}
	}
	
	return nil
}

// ImportNode represents an import statement
type ImportNode struct {
	source string
	module string
	line   int
}

// Implement Node interface for ImportNode
func (n *ImportNode) Render(w io.Writer, ctx *RenderContext) error {
	// Load the imported template
	template, err := ctx.engine.Load(n.source)
	if err != nil {
		return err
	}
	
	// Create a context for the imported template
	importContext := &RenderContext{
		env:     ctx.env,
		context: make(map[string]interface{}),
		blocks:  make(map[string][]Node),
		macros:  make(map[string]Node),
		engine:  ctx.engine,
	}
	
	// Render the template to collect macros (without output)
	var nullWriter NullWriter
	if err := template.nodes.Render(&nullWriter, importContext); err != nil {
		return err
	}
	
	// Create a module object to hold the imported macros
	module := make(map[string]interface{})
	
	// Add all macros from the imported template to the module
	for name, macro := range importContext.macros {
		module[name] = macro
	}
	
	// Set the module in the current context
	ctx.SetVariable(n.module, module)
	
	return nil
}

func (n *ImportNode) Type() NodeType {
	return NodeImport
}

func (n *ImportNode) Line() int {
	return n.line
}

// FromImportNode represents a from...import statement
type FromImportNode struct {
	source  string
	macros  []string
	aliases map[string]string
	line    int
}

// Implement Node interface for FromImportNode
func (n *FromImportNode) Render(w io.Writer, ctx *RenderContext) error {
	// Load the imported template
	template, err := ctx.engine.Load(n.source)
	if err != nil {
		return err
	}
	
	// Create a context for the imported template
	importContext := &RenderContext{
		env:     ctx.env,
		context: make(map[string]interface{}),
		blocks:  make(map[string][]Node),
		macros:  make(map[string]Node),
		engine:  ctx.engine,
	}
	
	// Render the template to collect macros (without output)
	var nullWriter NullWriter
	if err := template.nodes.Render(&nullWriter, importContext); err != nil {
		return err
	}
	
	// Import the specified macros directly into the current context
	if len(n.macros) > 0 {
		for _, name := range n.macros {
			if macro, ok := importContext.macros[name]; ok {
				ctx.macros[name] = macro
			}
		}
	}
	
	// Import macros with aliases
	if len(n.aliases) > 0 {
		for name, alias := range n.aliases {
			if macro, ok := importContext.macros[name]; ok {
				ctx.macros[alias] = macro
			}
		}
	}
	
	return nil
}

func (n *FromImportNode) Type() NodeType {
	return NodeImport
}

func (n *FromImportNode) Line() int {
	return n.line
}

// FilterNode represents a filter application
type FilterNode struct {
	node   Node
	filter string
	args   []Node
	line   int
}

// Implement Node interface for FilterNode
func (n *FilterNode) Render(w io.Writer, ctx *RenderContext) error {
	// Evaluate the input node
	input, err := ctx.EvaluateExpression(n.node)
	if err != nil {
		return err
	}
	
	// Evaluate filter arguments
	var args []interface{}
	for _, arg := range n.args {
		argValue, err := ctx.EvaluateExpression(arg)
		if err != nil {
			return err
		}
		args = append(args, argValue)
	}
	
	// Apply the filter
	result, err := ctx.ApplyFilter(n.filter, input, args)
	if err != nil {
		return err
	}
	
	// Write the result
	_, err = w.Write([]byte(ctx.ToString(result)))
	return err
}

func (n *FilterNode) Type() NodeType {
	return NodeExpression
}

func (n *FilterNode) Line() int {
	return n.line
}

// FunctionNode represents a function call
type FunctionNode struct {
	name string
	args []Node
	line int
}

// Implement Node interface for FunctionNode
func (n *FunctionNode) Render(w io.Writer, ctx *RenderContext) error {
	// Evaluate arguments
	var args []interface{}
	for _, arg := range n.args {
		argValue, err := ctx.EvaluateExpression(arg)
		if err != nil {
			return err
		}
		args = append(args, argValue)
	}
	
	// Call the function
	result, err := ctx.CallFunction(n.name, args)
	if err != nil {
		return err
	}
	
	// Write the result
	_, err = w.Write([]byte(ctx.ToString(result)))
	return err
}

func (n *FunctionNode) Type() NodeType {
	return NodeExpression
}

func (n *FunctionNode) Line() int {
	return n.line
}

// ArrayNode represents an array literal
type ArrayNode struct {
	items []Node
	line  int
}

// Implement Node interface for ArrayNode
func (n *ArrayNode) Render(w io.Writer, ctx *RenderContext) error {
	var items []interface{}
	
	// Evaluate all items
	for _, item := range n.items {
		value, err := ctx.EvaluateExpression(item)
		if err != nil {
			return err
		}
		items = append(items, value)
	}
	
	// Just return the array
	_, err := w.Write([]byte(ctx.ToString(items)))
	return err
}

func (n *ArrayNode) Type() NodeType {
	return NodeExpression
}

func (n *ArrayNode) Line() int {
	return n.line
}

// HashNode represents a hash/map literal
type HashNode struct {
	items map[string]Node
	line  int
}

// Implement Node interface for HashNode
func (n *HashNode) Render(w io.Writer, ctx *RenderContext) error {
	result := make(map[string]interface{})
	
	// Evaluate all items
	for key, value := range n.items {
		itemValue, err := ctx.EvaluateExpression(value)
		if err != nil {
			return err
		}
		result[key] = itemValue
	}
	
	// Just return the hash
	_, err := w.Write([]byte(ctx.ToString(result)))
	return err
}

func (n *HashNode) Type() NodeType {
	return NodeExpression
}

func (n *HashNode) Line() int {
	return n.line
}

// UnaryNode represents a unary operation
type UnaryNode struct {
	operator string
	node     Node
	line     int
}

// Implement Node interface for UnaryNode
func (n *UnaryNode) Render(w io.Writer, ctx *RenderContext) error {
	result, err := ctx.EvaluateExpression(n)
	if err != nil {
		return err
	}
	
	_, err = w.Write([]byte(ctx.ToString(result)))
	return err
}

func (n *UnaryNode) Type() NodeType {
	return NodeExpression
}

func (n *UnaryNode) Line() int {
	return n.line
}

// GetItemNode represents array/map item access
type GetItemNode struct {
	node  Node
	item  Node
	line  int
}

// Implement Node interface for GetItemNode
func (n *GetItemNode) Render(w io.Writer, ctx *RenderContext) error {
	result, err := ctx.EvaluateExpression(n)
	if err != nil {
		return err
	}
	
	_, err = w.Write([]byte(ctx.ToString(result)))
	return err
}

func (n *GetItemNode) Type() NodeType {
	return NodeExpression
}

func (n *GetItemNode) Line() int {
	return n.line
}

// NullWriter is a writer that discards all data
type NullWriter struct{}

func (w *NullWriter) Write(p []byte) (n int, err error) {
	return len(p), nil
}

// Constructor functions for new node types

// NewMacroNode creates a new macro node
func NewMacroNode(name string, params []string, defaults map[string]Node, body []Node, line int) *MacroNode {
	return &MacroNode{
		name:     name,
		params:   params,
		defaults: defaults,
		body:     body,
		line:     line,
	}
}

// NewImportNode creates a new import node
func NewImportNode(source Node, module string, line int) *ImportNode {
	sourceStr, _ := source.(*LiteralNode)
	return &ImportNode{
		source: sourceStr.value.(string),
		module: module,
		line:   line,
	}
}

// NewFromImportNode creates a new from...import node
func NewFromImportNode(source Node, macros []string, aliases map[string]string, line int) *FromImportNode {
	sourceStr, _ := source.(*LiteralNode)
	return &FromImportNode{
		source:  sourceStr.value.(string),
		macros:  macros,
		aliases: aliases,
		line:    line,
	}
}

// NewFilterNode creates a new filter node
func NewFilterNode(node Node, filter string, args []Node, line int) *FilterNode {
	return &FilterNode{
		node:   node,
		filter: filter,
		args:   args,
		line:   line,
	}
}

// NewFunctionNode creates a new function call node
func NewFunctionNode(name string, args []Node, line int) *FunctionNode {
	return &FunctionNode{
		name: name,
		args: args,
		line: line,
	}
}

// NewArrayNode creates a new array literal node
func NewArrayNode(items []Node, line int) *ArrayNode {
	return &ArrayNode{
		items: items,
		line:  line,
	}
}

// NewHashNode creates a new hash literal node
func NewHashNode(items map[string]Node, line int) *HashNode {
	return &HashNode{
		items: items,
		line:  line,
	}
}

// NewUnaryNode creates a new unary operation node
func NewUnaryNode(operator string, node Node, line int) *UnaryNode {
	return &UnaryNode{
		operator: operator,
		node:     node,
		line:     line,
	}
}

// NewGetItemNode creates a new array/map item access node
func NewGetItemNode(node Node, item Node, line int) *GetItemNode {
	return &GetItemNode{
		node: node,
		item: item,
		line: line,
	}
}
`

func main() {
	// Parse command line arguments
	outputDir := flag.String("output", ".", "Output directory for generated files")
	flag.Parse()

	// Define the grammar rules
	rules := []GrammarRule{
		// Add your grammar rules here
	}

	// Create data for template
	data := struct {
		Rules []GrammarRule
	}{
		Rules: rules,
	}

	// Create output directory if it doesn't exist
	err := os.MkdirAll(*outputDir, 0755)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output directory: %v\n", err)
		os.Exit(1)
	}

	// Generate parser file
	parserFilePath := filepath.Join(*outputDir, "parser.gen.go")
	if err := generateFromTemplate(parserTmpl, parserFilePath, data); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating parser file: %v\n", err)
		os.Exit(1)
	}

	// Generate node types file
	nodesFilePath := filepath.Join(*outputDir, "nodes.gen.go")
	if err := generateFromTemplate(nodesTmpl, nodesFilePath, data); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating nodes file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated files:\n- %s\n- %s\n", parserFilePath, nodesFilePath)
}

func generateFromTemplate(tmplText, outFile string, data interface{}) error {
	// Parse template
	tmpl, err := template.New("").Parse(tmplText)
	if err != nil {
		return fmt.Errorf("error parsing template: %w", err)
	}

	// Create output file
	f, err := os.Create(outFile)
	if err != nil {
		return fmt.Errorf("error creating file %s: %w", outFile, err)
	}
	defer f.Close()

	// Execute template
	if err := tmpl.Execute(f, data); err != nil {
		return fmt.Errorf("error executing template: %w", err)
	}

	return nil
}